#BlueJ class context
comment0.target=StdIn
comment0.text=\n\ \ The\ {@code\ StdIn}\ class\ provides\ static\ methods\ for\ reading\ strings\n\ \ and\ numbers\ from\ standard\ input.\n\ \ These\ functions\ fall\ into\ one\ of\ four\ categories\:\n\ \ <ul>\n\ \ <li>those\ for\ reading\ individual\ tokens\ from\ standard\ input,\ one\ at\ a\ time,\n\ \ \ \ \ \ and\ converting\ each\ to\ a\ number,\ string,\ or\ boolean\n\ \ <li>those\ for\ reading\ characters\ from\ standard\ input,\ one\ at\ a\ time\n\ \ <li>those\ for\ reading\ lines\ from\ standard\ input,\ one\ at\ a\ time\n\ \ <li>those\ for\ reading\ a\ sequence\ of\ values\ of\ the\ same\ type\ from\ standard\ input,\n\ \ \ \ \ \ and\ returning\ the\ values\ in\ an\ array\n\ \ </ul>\n\ \ <p>\n\ \ Generally,\ it\ is\ best\ not\ to\ mix\ functions\ from\ the\ different\n\ \ categories\ in\ the\ same\ program.\n\ \ <p>\n\ \ <b>Getting\ started.</b>\n\ \ To\ use\ this\ class,\ you\ must\ have\ {@code\ StdIn.class}\ in\ your\n\ \ Java\ classpath.\ If\ you\ used\ our\ autoinstaller,\ you\ should\ be\ all\ set.\n\ \ Otherwise,\ either\ download\n\ \ <a\ href\ \=\ "https\://introcs.cs.princeton.edu/java/code/stdlib.jar">stdlib.jar</a>\n\ \ and\ add\ to\ your\ Java\ classpath\ or\ download\n\ \ <a\ href\ \=\ "https\://introcs.cs.princeton.edu/java/stdlib/StdIn.java">StdIn.java</a>\n\ \ and\ put\ a\ copy\ in\ your\ working\ directory.\n\ \ <p>\n\ \ <b>Reading\ tokens\ from\ standard\ input\ and\ converting\ to\ numbers\ and\ strings.</b>\n\ \ You\ can\ use\ the\ following\ methods\ to\ read\ numbers,\ strings,\ and\ booleans\n\ \ from\ standard\ input\ one\ at\ a\ time\:\n\ \ <ul>\n\ \ <li>\ {@link\ \#isEmpty()}\n\ \ <li>\ {@link\ \#readInt()}\n\ \ <li>\ {@link\ \#readDouble()}\n\ \ <li>\ {@link\ \#readString()}\n\ \ <li>\ {@link\ \#readShort()}\n\ \ <li>\ {@link\ \#readLong()}\n\ \ <li>\ {@link\ \#readFloat()}\n\ \ <li>\ {@link\ \#readByte()}\n\ \ <li>\ {@link\ \#readBoolean()}\n\ \ </ul>\n\ \ <p>\n\ \ The\ first\ method\ returns\ true\ if\ standard\ input\ has\ no\ more\ tokens.\n\ \ Each\ other\ method\ skips\ over\ any\ input\ that\ is\ whitespace.\ Then,\ it\ reads\n\ \ the\ next\ token\ and\ attempts\ to\ convert\ it\ into\ a\ value\ of\ the\ specified\n\ \ type.\ If\ it\ succeeds,\ it\ returns\ that\ value;\ otherwise,\ it\n\ \ throws\ an\ {@link\ InputMismatchException}.\n\ \ <p>\n\ \ <em>Whitespace</em>\ includes\ spaces,\ tabs,\ and\ newlines;\ the\ full\ definition\n\ \ is\ inherited\ from\ {@link\ Character\#isWhitespace(char)}.\n\ \ A\ <em>token</em>\ is\ a\ maximal\ sequence\ of\ non-whitespace\ characters.\n\ \ The\ precise\ rules\ for\ describing\ which\ tokens\ can\ be\ converted\ to\n\ \ integers\ and\ floating-point\ numbers\ are\ inherited\ from\n\ \ <a\ href\ \=\ "http\://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html\#number-syntax">Scanner</a>,\n\ \ using\ the\ locale\ {@link\ Locale\#US};\ the\ rules\n\ \ for\ floating-point\ numbers\ are\ slightly\ different\n\ \ from\ those\ in\ {@link\ Double\#valueOf(String)},\n\ \ but\ unlikely\ to\ be\ of\ concern\ to\ most\ programmers.\n\ \ <p>\n\ \ As\ an\ example,\ the\ following\ code\ fragment\ reads\ integers\ from\ standard\ input,\n\ \ one\ at\ a\ time,\ and\ prints\ them\ one\ per\ line.\n\ \ <pre>\n\ \ while\ (\!StdIn.isEmpty())\ {\n\ \ \ \ \ \ double\ value\ \=\ StdIn.readDouble();\n\ \ \ \ \ \ StdOut.println(value);\n\ \ }\n\ \ </pre>\n\ \ <p>\n\ \ <b>Reading\ characters\ from\ standard\ input.</b>\n\ \ You\ can\ use\ the\ following\ two\ methods\ to\ read\ characters\ from\ standard\ input\ one\ at\ a\ time\:\n\ \ <ul>\n\ \ <li>\ {@link\ \#hasNextChar()}\n\ \ <li>\ {@link\ \#readChar()}\n\ \ </ul>\n\ \ <p>\n\ \ The\ first\ method\ returns\ true\ if\ standard\ input\ has\ more\ input\ (including\ whitespace).\n\ \ The\ second\ method\ reads\ and\ returns\ the\ next\ character\ of\ input\ on\ standard\ \n\ \ input\ (possibly\ a\ whitespace\ character).\n\ \ <p>\n\ \ As\ an\ example,\ the\ following\ code\ fragment\ reads\ characters\ from\ standard\ input,\n\ \ one\ character\ at\ a\ time,\ and\ prints\ it\ to\ standard\ output.\n\ \ <pre>\n\ \ while\ (StdIn.hasNextChar())\ {\n\ \ \ \ \ \ char\ c\ \=\ StdIn.readChar();\n\ \ \ \ \ \ StdOut.print(c);\n\ \ }\n\ \ </pre>\n\ \ <p>\n\ \ <b>Reading\ lines\ from\ standard\ input.</b>\n\ \ You\ can\ use\ the\ following\ two\ methods\ to\ read\ lines\ from\ standard\ input\:\n\ \ <ul>\n\ \ <li>\ {@link\ \#hasNextLine()}\n\ \ <li>\ {@link\ \#readLine()}\n\ \ </ul>\n\ \ <p>\n\ \ The\ first\ method\ returns\ true\ if\ standard\ input\ has\ more\ input\ (including\ whitespace).\n\ \ The\ second\ method\ reads\ and\ returns\ the\ remaining\ portion\ of\ \n\ \ the\ next\ line\ of\ input\ on\ standard\ input\ (possibly\ whitespace),\n\ \ discarding\ the\ trailing\ line\ separator.\n\ \ <p>\n\ \ A\ <em>line\ separator</em>\ is\ defined\ to\ be\ one\ of\ the\ following\ strings\:\n\ \ {@code\ \\n}\ (Linux),\ {@code\ \\r}\ (old\ Macintosh),\n\ \ {@code\ \\r\\n}\ (Windows),\n\ \ {@code\ \\}{@code\ u2028},\ {@code\ \\}{@code\ u2029},\ or\ {@code\ \\}{@code\ u0085}.\n\ \ <p>\n\ \ As\ an\ example,\ the\ following\ code\ fragment\ reads\ text\ from\ standard\ input,\n\ \ one\ line\ at\ a\ time,\ and\ prints\ it\ to\ standard\ output.\n\ \ <pre>\n\ \ while\ (StdIn.hasNextLine())\ {\n\ \ \ \ \ \ String\ line\ \=\ StdIn.readLine();\n\ \ \ \ \ \ StdOut.println(line);\n\ \ }\n\ \ </pre>\n\ \ <p>\n\ \ <b>Reading\ a\ sequence\ of\ values\ of\ the\ same\ type\ from\ standard\ input.</b>\n\ \ You\ can\ use\ the\ following\ methods\ to\ read\ a\ sequence\ numbers,\ strings,\n\ \ or\ booleans\ (all\ of\ the\ same\ type)\ from\ standard\ input\:\n\ \ <ul>\n\ \ <li>\ {@link\ \#readAllDoubles()}\n\ \ <li>\ {@link\ \#readAllInts()}\n\ \ <li>\ {@link\ \#readAllLongs()}\n\ \ <li>\ {@link\ \#readAllStrings()}\n\ \ <li>\ {@link\ \#readAllLines()}\n\ \ <li>\ {@link\ \#readAll()}\n\ \ </ul>\n\ \ <p>\n\ \ The\ first\ three\ methods\ read\ of\ all\ of\ remaining\ token\ on\ standard\ input\n\ \ and\ converts\ the\ tokens\ to\ values\ of\n\ \ the\ specified\ type,\ as\ in\ the\ corresponding\n\ \ {@code\ readDouble},\ {@code\ readInt},\ and\ {@code\ readString()}\ methods.\n\ \ The\ {@code\ readAllLines()}\ method\ reads\ all\ remaining\ lines\ on\ standard\n\ \ input\ and\ returns\ them\ as\ an\ array\ of\ strings.\n\ \ The\ {@code\ readAll()}\ method\ reads\ all\ remaining\ input\ on\ standard\n\ \ input\ and\ returns\ it\ as\ a\ string.\n\ \ <p>\n\ \ As\ an\ example,\ the\ following\ code\ fragment\ reads\ all\ of\ the\ remaining\n\ \ tokens\ from\ standard\ input\ and\ returns\ them\ as\ an\ array\ of\ strings.\n\ \ <pre>\n\ \ String[]\ words\ \=\ StdIn.readAllStrings();\n\ \ </pre>\n\ \ <p>\n\ \ <b>Differences\ with\ Scanner.</b>\n\ \ {@code\ StdIn}\ and\ {@link\ Scanner}\ are\ both\ designed\ to\ parse\ \n\ \ tokens\ and\ convert\ them\ to\ primitive\ types\ and\ strings.\n\ \ The\ main\ differences\ are\ summarized\ below\:\n\ \ <ul>\n\ \ <li>\ {@code\ StdIn}\ is\ a\ set\ of\ static\ methods\ and\ reads\ \n\ \ \ \ \ \ \ reads\ input\ from\ only\ standard\ input.\ It\ is\ suitable\ for\ use\ before\n\ \ \ \ \ \ \ a\ programmer\ knows\ about\ objects.\n\ \ \ \ \ \ \ See\ {@link\ In}\ for\ an\ object-oriented\ version\ that\ handles\n\ \ \ \ \ \ \ input\ from\ files,\ URLs,\n\ \ \ \ \ \ \ and\ sockets.\n\ \ <li>\ {@code\ StdIn}\ uses\ whitespace\ as\ the\ delimiter\ pattern\n\ \ \ \ \ \ \ that\ separates\ tokens.\n\ \ \ \ \ \ \ {@link\ Scanner}\ supports\ arbitrary\ delimiter\ patterns.\n\ \ <li>\ {@code\ StdIn}\ coerces\ the\ character-set\ encoding\ to\ UTF-8,\n\ \ \ \ \ \ \ which\ is\ the\ most\ widely\ used\ character\ encoding\ for\ Unicode.\n\ \ <li>\ {@code\ StdIn}\ coerces\ the\ locale\ to\ {@link\ Locale\#US},\n\ \ \ \ \ \ \ for\ consistency\ with\ {@link\ StdOut},\ {@link\ Double\#parseDouble(String)},\n\ \ \ \ \ \ \ and\ floating-point\ literals.\n\ \ <li>\ {@code\ StdIn}\ has\ convenient\ methods\ for\ reading\ a\ single\n\ \ \ \ \ \ \ character;\ reading\ in\ sequences\ of\ integers,\ doubles,\ or\ strings;\n\ \ \ \ \ \ \ and\ reading\ in\ all\ of\ the\ remaining\ input.\n\ \ </ul>\n\ \ <p>\n\ \ Historical\ note\:\ {@code\ StdIn}\ preceded\ {@code\ Scanner};\ when\n\ \ {@code\ Scanner}\ was\ introduced,\ this\ class\ was\ re-implemented\ to\ use\ {@code\ Scanner}.\n\ \ <p>\n\ \ <b>Using\ standard\ input.</b>\n\ \ Standard\ input\ is\ a\ fundamental\ operating\ system\ abstraction\ on\ Mac\ OS\ X,\n\ \ Windows,\ and\ Linux.\n\ \ The\ methods\ in\ {@code\ StdIn}\ are\ <em>blocking</em>,\ which\ means\ that\ they\n\ \ will\ wait\ until\ you\ enter\ input\ on\ standard\ input.\n\ \ If\ your\ program\ has\ a\ loop\ that\ repeats\ until\ standard\ input\ is\ empty,\n\ \ you\ must\ signal\ that\ the\ input\ is\ finished.\n\ \ To\ do\ so,\ depending\ on\ your\ operating\ system\ and\ IDE,\ \n\ \ use\ either\ {@code\ <Ctrl-d>}\ or\ {@code\ <Ctrl-z>},\ on\ its\ own\ line.\n\ \ If\ you\ are\ redirecting\ standard\ input\ from\ a\ file,\ you\ will\ not\ need\n\ \ to\ do\ anything\ to\ signal\ that\ the\ input\ is\ finished.\n\ \ <p>\n\ \ <b>Known\ bugs.</b>\n\ \ Java's\ UTF-8\ encoding\ does\ not\ recognize\ the\ optional\ \n\ \ <a\ href\ \=\ "http\://bugs.sun.com/bugdatabase/view_bug.do?bug_id\=4508058">byte-order\ mask</a>.\n\ \ If\ the\ input\ begins\ with\ the\ optional\ byte-order\ mask,\ {@code\ StdIn}\n\ \ will\ have\ an\ extra\ character\ {@code\ \\}{@code\ uFEFF}\ at\ the\ beginning.\n\ \ <p>\n\ \ <b>Reference.</b>\ \n\ \ For\ additional\ documentation,\n\ \ see\ <a\ href\="https\://introcs.cs.princeton.edu/15inout">Section\ 1.5</a>\ of\ \ \ \n\ \ <em>Computer\ Science\:\ An\ Interdisciplinary\ Approach</em>\n\ \ by\ Robert\ Sedgewick\ and\ Kevin\ Wayne.\n\n\ \ @author\ Robert\ Sedgewick\n\ \ @author\ Kevin\ Wayne\n\ \ @author\ David\ Pritchard\n
comment1.params=
comment1.target=StdIn()
comment10.params=
comment10.target=double\ readDouble()
comment10.text=\n\ Reads\ the\ next\ token\ from\ standard\ input,\ parses\ it\ as\ a\ double,\ and\ returns\ the\ double.\n\n\ @return\ the\ next\ double\ on\ standard\ input\n\ @throws\ NoSuchElementException\ if\ standard\ input\ is\ empty\n\ @throws\ InputMismatchException\ if\ the\ next\ token\ cannot\ be\ parsed\ as\ a\ {@code\ double}\n
comment11.params=
comment11.target=float\ readFloat()
comment11.text=\n\ Reads\ the\ next\ token\ from\ standard\ input,\ parses\ it\ as\ a\ float,\ and\ returns\ the\ float.\n\n\ @return\ the\ next\ float\ on\ standard\ input\n\ @throws\ NoSuchElementException\ if\ standard\ input\ is\ empty\n\ @throws\ InputMismatchException\ if\ the\ next\ token\ cannot\ be\ parsed\ as\ a\ {@code\ float}\n
comment12.params=
comment12.target=long\ readLong()
comment12.text=\n\ Reads\ the\ next\ token\ from\ standard\ input,\ parses\ it\ as\ a\ long\ integer,\ and\ returns\ the\ long\ integer.\n\n\ @return\ the\ next\ long\ integer\ on\ standard\ input\n\ @throws\ NoSuchElementException\ if\ standard\ input\ is\ empty\n\ @throws\ InputMismatchException\ if\ the\ next\ token\ cannot\ be\ parsed\ as\ a\ {@code\ long}\n
comment13.params=
comment13.target=short\ readShort()
comment13.text=\n\ Reads\ the\ next\ token\ from\ standard\ input,\ parses\ it\ as\ a\ short\ integer,\ and\ returns\ the\ short\ integer.\n\n\ @return\ the\ next\ short\ integer\ on\ standard\ input\n\ @throws\ NoSuchElementException\ if\ standard\ input\ is\ empty\n\ @throws\ InputMismatchException\ if\ the\ next\ token\ cannot\ be\ parsed\ as\ a\ {@code\ short}\n
comment14.params=
comment14.target=byte\ readByte()
comment14.text=\n\ Reads\ the\ next\ token\ from\ standard\ input,\ parses\ it\ as\ a\ byte,\ and\ returns\ the\ byte.\n\n\ @return\ the\ next\ byte\ on\ standard\ input\n\ @throws\ NoSuchElementException\ if\ standard\ input\ is\ empty\n\ @throws\ InputMismatchException\ if\ the\ next\ token\ cannot\ be\ parsed\ as\ a\ {@code\ byte}\n
comment15.params=
comment15.target=boolean\ readBoolean()
comment15.text=\n\ Reads\ the\ next\ token\ from\ standard\ input,\ parses\ it\ as\ a\ boolean,\n\ and\ returns\ the\ boolean.\n\n\ @return\ the\ next\ boolean\ on\ standard\ input\n\ @throws\ NoSuchElementException\ if\ standard\ input\ is\ empty\n\ @throws\ InputMismatchException\ if\ the\ next\ token\ cannot\ be\ parsed\ as\ a\ {@code\ boolean}\:\n\ \ \ \ {@code\ true}\ or\ {@code\ 1}\ for\ true,\ and\ {@code\ false}\ or\ {@code\ 0}\ for\ false,\n\ \ \ \ ignoring\ case\n
comment16.params=
comment16.target=java.lang.String[]\ readAllStrings()
comment16.text=\n\ Reads\ all\ remaining\ tokens\ from\ standard\ input\ and\ returns\ them\ as\ an\ array\ of\ strings.\n\n\ @return\ all\ remaining\ tokens\ on\ standard\ input,\ as\ an\ array\ of\ strings\n
comment17.params=
comment17.target=java.lang.String[]\ readAllLines()
comment17.text=\n\ Reads\ all\ remaining\ lines\ from\ standard\ input\ and\ returns\ them\ as\ an\ array\ of\ strings.\n\ @return\ all\ remaining\ lines\ on\ standard\ input,\ as\ an\ array\ of\ strings\n
comment18.params=
comment18.target=int[]\ readAllInts()
comment18.text=\n\ Reads\ all\ remaining\ tokens\ from\ standard\ input,\ parses\ them\ as\ integers,\ and\ returns\n\ them\ as\ an\ array\ of\ integers.\n\ @return\ all\ remaining\ integers\ on\ standard\ input,\ as\ an\ array\n\ @throws\ InputMismatchException\ if\ any\ token\ cannot\ be\ parsed\ as\ an\ {@code\ int}\n
comment19.params=
comment19.target=long[]\ readAllLongs()
comment19.text=\n\ Reads\ all\ remaining\ tokens\ from\ standard\ input,\ parses\ them\ as\ longs,\ and\ returns\n\ them\ as\ an\ array\ of\ longs.\n\ @return\ all\ remaining\ longs\ on\ standard\ input,\ as\ an\ array\n\ @throws\ InputMismatchException\ if\ any\ token\ cannot\ be\ parsed\ as\ a\ {@code\ long}\n
comment2.params=
comment2.target=boolean\ isEmpty()
comment2.text=\n\ Returns\ true\ if\ standard\ input\ is\ empty\ (except\ possibly\ for\ whitespace).\n\ Use\ this\ method\ to\ know\ whether\ the\ next\ call\ to\ {@link\ \#readString()},\ \n\ {@link\ \#readDouble()},\ etc\ will\ succeed.\n\n\ @return\ {@code\ true}\ if\ standard\ input\ is\ empty\ (except\ possibly\n\ \ \ \ \ \ \ \ \ for\ whitespace);\ {@code\ false}\ otherwise\n
comment20.params=
comment20.target=double[]\ readAllDoubles()
comment20.text=\n\ Reads\ all\ remaining\ tokens\ from\ standard\ input,\ parses\ them\ as\ doubles,\ and\ returns\n\ them\ as\ an\ array\ of\ doubles.\n\ @return\ all\ remaining\ doubles\ on\ standard\ input,\ as\ an\ array\n\ @throws\ InputMismatchException\ if\ any\ token\ cannot\ be\ parsed\ as\ a\ {@code\ double}\n
comment21.params=
comment21.target=void\ resync()
comment21.text=\n\ If\ StdIn\ changes,\ use\ this\ to\ reinitialize\ the\ scanner.\n
comment22.params=scanner
comment22.target=void\ setScanner(java.util.Scanner)
comment23.params=
comment23.target=int[]\ readInts()
comment23.text=\n\ Reads\ all\ remaining\ tokens,\ parses\ them\ as\ integers,\ and\ returns\n\ them\ as\ an\ array\ of\ integers.\n\ @return\ all\ remaining\ integers,\ as\ an\ array\n\ @throws\ InputMismatchException\ if\ any\ token\ cannot\ be\ parsed\ as\ an\ {@code\ int}\n\ @deprecated\ Replaced\ by\ {@link\ \#readAllInts()}.\n
comment24.params=
comment24.target=double[]\ readDoubles()
comment24.text=\n\ Reads\ all\ remaining\ tokens,\ parses\ them\ as\ doubles,\ and\ returns\n\ them\ as\ an\ array\ of\ doubles.\n\ @return\ all\ remaining\ doubles,\ as\ an\ array\n\ @throws\ InputMismatchException\ if\ any\ token\ cannot\ be\ parsed\ as\ a\ {@code\ double}\n\ @deprecated\ Replaced\ by\ {@link\ \#readAllDoubles()}.\n
comment25.params=
comment25.target=java.lang.String[]\ readStrings()
comment25.text=\n\ Reads\ all\ remaining\ tokens\ and\ returns\ them\ as\ an\ array\ of\ strings.\n\ @return\ all\ remaining\ tokens,\ as\ an\ array\ of\ strings\n\ @deprecated\ Replaced\ by\ {@link\ \#readAllStrings()}.\n
comment26.params=filename
comment26.target=void\ setFile(java.lang.String)
comment27.params=args
comment27.target=void\ main(java.lang.String[])
comment27.text=\n\ Interactive\ test\ of\ basic\ functionality.\n\n\ @param\ args\ the\ command-line\ arguments\n
comment3.params=
comment3.target=boolean\ hasNextLine()
comment3.text=\n\ Returns\ true\ if\ standard\ input\ has\ a\ next\ line.\n\ Use\ this\ method\ to\ know\ whether\ the\n\ next\ call\ to\ {@link\ \#readLine()}\ will\ succeed.\n\ This\ method\ is\ functionally\ equivalent\ to\ {@link\ \#hasNextChar()}.\n\n\ @return\ {@code\ true}\ if\ standard\ input\ has\ more\ input\ (including\ whitespace);\n\ \ \ \ \ \ \ \ \ {@code\ false}\ otherwise\n
comment4.params=
comment4.target=boolean\ hasNextChar()
comment4.text=\n\ Returns\ true\ if\ standard\ input\ has\ more\ input\ (including\ whitespace).\n\ Use\ this\ method\ to\ know\ whether\ the\ next\ call\ to\ {@link\ \#readChar()}\ will\ succeed.\n\ This\ method\ is\ functionally\ equivalent\ to\ {@link\ \#hasNextLine()}.\n\n\ @return\ {@code\ true}\ if\ standard\ input\ has\ more\ input\ (including\ whitespace);\n\ \ \ \ \ \ \ \ \ {@code\ false}\ otherwise\n
comment5.params=
comment5.target=java.lang.String\ readLine()
comment5.text=\n\ Reads\ and\ returns\ the\ next\ line,\ excluding\ the\ line\ separator\ if\ present.\n\n\ @return\ the\ next\ line,\ excluding\ the\ line\ separator\ if\ present;\n\ \ \ \ \ \ \ \ \ {@code\ null}\ if\ no\ such\ line\n
comment6.params=
comment6.target=char\ readChar()
comment6.text=\n\ Reads\ and\ returns\ the\ next\ character.\n\n\ @return\ the\ next\ {@code\ char}\n\ @throws\ NoSuchElementException\ if\ standard\ input\ is\ empty\n
comment7.params=
comment7.target=java.lang.String\ readAll()
comment7.text=\n\ Reads\ and\ returns\ the\ remainder\ of\ the\ input,\ as\ a\ string.\n\n\ @return\ the\ remainder\ of\ the\ input,\ as\ a\ string\n\ @throws\ NoSuchElementException\ if\ standard\ input\ is\ empty\n
comment8.params=
comment8.target=java.lang.String\ readString()
comment8.text=\n\ Reads\ the\ next\ token\ \ and\ returns\ the\ {@code\ String}.\n\n\ @return\ the\ next\ {@code\ String}\n\ @throws\ NoSuchElementException\ if\ standard\ input\ is\ empty\n
comment9.params=
comment9.target=int\ readInt()
comment9.text=\n\ Reads\ the\ next\ token\ from\ standard\ input,\ parses\ it\ as\ an\ integer,\ and\ returns\ the\ integer.\n\n\ @return\ the\ next\ integer\ on\ standard\ input\n\ @throws\ NoSuchElementException\ if\ standard\ input\ is\ empty\n\ @throws\ InputMismatchException\ if\ the\ next\ token\ cannot\ be\ parsed\ as\ an\ {@code\ int}\n
numComments=28
